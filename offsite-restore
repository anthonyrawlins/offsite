#!/bin/bash
set -euo pipefail

# Offsite Restore - Single Dataset
# Downloads and restores encrypted chunks from cloud storage

# === USAGE ===
if [[ $# -lt 1 ]] || [[ $# -gt 3 ]] || [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    echo "Usage: $0 <dataset[@backup]> [provider] [target_dataset]"
    echo ""
    echo "ZFS-style syntax for dataset and backup selection:"
    echo "  dataset              - Restore full dataset state (latest backup)"
    echo "  dataset@latest       - Same as above (ZFS semantics)"
    echo "  dataset@latest-full  - Most recent full backup only"
    echo "  dataset@backup-name  - Specific backup point in time"
    echo ""
    echo "Providers:"
    echo "  auto       - Try all providers (Backblaze first) [default]"
    echo "  backblaze  - Restore from Backblaze (US)"
    echo "  scaleway   - Restore from Scaleway (EU)"
    echo "  custom     - Any configured provider name"
    echo ""
    echo "Arguments:"
    echo "  dataset[@backup] - Dataset with optional @backup specifier"
    echo "  provider         - Optional: provider name (default: auto)"
    echo "  target_dataset   - Optional: New dataset name (default: dataset-restored)"
    echo ""
    echo "Examples:"
    echo "  $0 tank/important/data@latest"
    echo "    # Restores latest backup to tank/important/data-restored"
    echo ""
    echo "  $0 tank/photos@latest-full backblaze"
    echo "    # Restores latest full backup from Backblaze to tank/photos-restored"
    echo ""
    echo "  $0 tank/docs@full-auto-20250716-161605 scaleway tank/docs-test"
    echo "    # Restores specific backup to tank/docs-test"
    echo ""
    echo "  $0 tank/media scaleway"
    echo "    # Restores latest backup from Scaleway (same as @latest)"
    exit 1
fi

# === PARSE ZFS-STYLE ARGUMENTS ===
DATASET_ARG="$1"
PROVIDER="${2:-auto}"
TARGET_DATASET="$3"

# Parse dataset@backup syntax
if [[ "$DATASET_ARG" =~ @ ]]; then
    SOURCE_DATASET="${DATASET_ARG%@*}"
    BACKUP_PREFIX="${DATASET_ARG#*@}"
    
    # ZFS semantics: dataset and dataset@latest are identical
    if [[ "$BACKUP_PREFIX" == "latest" ]]; then
        echo "Note: dataset@latest is the same as dataset (full dataset state)"
    fi
else
    SOURCE_DATASET="$DATASET_ARG"
    BACKUP_PREFIX="latest"
fi

# Set default target if not specified
if [[ -z "$TARGET_DATASET" ]]; then
    TARGET_DATASET="${SOURCE_DATASET}-restored"
fi

# === LOAD CONFIG ===
CONFIG_FILE="${OFFSITE_CONFIG:-$HOME/.config/offsite/config.env}"
if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE"
else
    echo "WARNING: Config file not found at $CONFIG_FILE"
    echo "Using default values or environment variables"
fi

# === CONFIG WITH DEFAULTS ===
AGE_PRIVATE_KEY_FILE="${AGE_PRIVATE_KEY_FILE:-$HOME/.config/age/zfs-backup.txt}"
TEMP_DIR="${TEMP_DIR:-/tmp}"

# === DISCOVER PROVIDERS ===
declare -A PROVIDERS
declare -A PROVIDER_NAMES

# Built-in providers
PROVIDERS[backblaze]="${RCLONE_REMOTE:-cloudremote:zfs-buckets-walnut-deepblack-cloud/zfs-backups}"
PROVIDER_NAMES[backblaze]="Backblaze (US)"

PROVIDERS[scaleway]="${SCALEWAY_REMOTE:-scaleway:zfs-buckets-acacia/zfs-backups}"
PROVIDER_NAMES[scaleway]="Scaleway (EU)"

# Discover custom providers from config (any variable ending with _REMOTE)
if [[ -f "$CONFIG_FILE" ]]; then
    while IFS='=' read -r key value; do
        [[ "$key" =~ ^[A-Z_]+_REMOTE$ ]] && [[ "$key" != "RCLONE_REMOTE" ]] && [[ "$key" != "SCALEWAY_REMOTE" ]] && {
            provider_name=$(echo "$key" | sed 's/_REMOTE$//' | tr '[:upper:]' '[:lower:]')
            PROVIDERS[$provider_name]="$value"
            PROVIDER_NAMES[$provider_name]="$provider_name"
        }
    done < <(grep -E '^[A-Z_]+_REMOTE=' "$CONFIG_FILE" | sed 's/^export //')
fi

# === VALIDATION ===
[[ -f "$AGE_PRIVATE_KEY_FILE" ]] || { echo "ERROR: Age private key not found at $AGE_PRIVATE_KEY_FILE"; exit 1; }
command -v rclone >/dev/null || { echo "ERROR: rclone not installed"; exit 1; }
command -v age >/dev/null || { echo "ERROR: age not installed"; exit 1; }
command -v zfs >/dev/null || { echo "ERROR: zfs not installed"; exit 1; }

# === PROVIDER SELECTION ===
case "$PROVIDER" in
    auto)
        # Try all providers, prefer backblaze
        echo "Auto mode: Testing all providers..."
        DATASET_PATH="${SOURCE_DATASET//\//_}"
        SELECTED_REMOTE=""
        PROVIDER_NAME=""
        
        # Try providers in order of preference
        for provider in backblaze scaleway $(printf '%s\n' "${!PROVIDERS[@]}" | grep -v -E '^(backblaze|scaleway)$' | sort); do
            remote="${PROVIDERS[$provider]}"
            if rclone lsf "${remote}/${DATASET_PATH}/" 2>/dev/null | grep -q "^${BACKUP_PREFIX}-x001.zfs.gz.age$"; then
                SELECTED_REMOTE="$remote"
                PROVIDER_NAME="${PROVIDER_NAMES[$provider]} - auto-selected"
                echo "Found backup on $provider"
                break
            fi
        done
        
        if [[ -z "$SELECTED_REMOTE" ]]; then
            echo "ERROR: Backup not found on any provider"
            echo "Available providers: ${!PROVIDERS[*]}"
            exit 1
        fi
        ;;
    *)
        # Handle legacy aliases
        case "$PROVIDER" in
            bb) PROVIDER="backblaze" ;;
            scw) PROVIDER="scaleway" ;;
        esac
        
        if [[ -z "${PROVIDERS[$PROVIDER]:-}" ]]; then
            echo "ERROR: Unknown provider '$PROVIDER'"
            echo "Available providers: ${!PROVIDERS[*]}"
            exit 1
        fi
        
        SELECTED_REMOTE="${PROVIDERS[$PROVIDER]}"
        PROVIDER_NAME="${PROVIDER_NAMES[$PROVIDER]}"
        ;;
esac

# === SETUP VARIABLES ===
DATASET_PATH="${SOURCE_DATASET//\//_}"
REMOTE_PATH="${SELECTED_REMOTE}/${DATASET_PATH}"

echo "=== Offsite Restore ==="
echo "Provider: $PROVIDER_NAME"
echo "Source dataset: $SOURCE_DATASET"
echo "Target dataset: $TARGET_DATASET"
echo "Remote path: $REMOTE_PATH"
echo ""

# === BACKUP SELECTION ===
if [[ "$BACKUP_PREFIX" == "latest" ]] || [[ "$BACKUP_PREFIX" == "latest-full" ]]; then
    echo "Discovering available backups..."
    
    # Get all backup prefixes for this dataset
    ALL_BACKUPS=($(rclone lsf "${REMOTE_PATH}/" 2>/dev/null | grep -E '^(full|incr)-.*-x[0-9][0-9][0-9]\.zfs\.gz\.age$' | sed 's/-x[0-9][0-9][0-9]\.zfs\.gz\.age$//' | sort -u | sort -t- -k3,3 || true))
    
    if [[ ${#ALL_BACKUPS[@]} -eq 0 ]]; then
        echo "ERROR: No backups found for dataset $SOURCE_DATASET"
        exit 1
    fi
    
    if [[ "$BACKUP_PREFIX" == "latest-full" ]]; then
        # Find latest full backup
        SELECTED_BACKUP=""
        for backup in "${ALL_BACKUPS[@]}"; do
            if [[ "$backup" =~ ^full- ]]; then
                SELECTED_BACKUP="$backup"
            fi
        done
        
        if [[ -z "$SELECTED_BACKUP" ]]; then
            echo "ERROR: No full backups found for dataset $SOURCE_DATASET"
            exit 1
        fi
        
        BACKUP_PREFIX="$SELECTED_BACKUP"
        echo "Selected latest full backup: $BACKUP_PREFIX"
    else
        # Find latest backup (incremental preferred)
        BACKUP_PREFIX="${ALL_BACKUPS[-1]}"
        echo "Selected latest backup: $BACKUP_PREFIX"
    fi
    
    echo "Available backups for $SOURCE_DATASET:"
    printf '%s\n' "${ALL_BACKUPS[@]}" | tail -5
    echo ""
else
    echo "Using specified backup: $BACKUP_PREFIX"
fi

echo "Final backup selection: $BACKUP_PREFIX"
echo ""

# === DISCOVER CHUNKS ===
echo "Discovering backup chunks..."
CHUNK_FILES=($(rclone lsf "${REMOTE_PATH}/" 2>/dev/null | grep "^${BACKUP_PREFIX}-x[0-9][0-9][0-9].zfs.gz.age$" | sort))

if [[ ${#CHUNK_FILES[@]} -eq 0 ]]; then
    echo "ERROR: No chunks found for backup prefix: ${BACKUP_PREFIX}"
    echo ""
    echo "Available backups for ${SOURCE_DATASET} on $PROVIDER_NAME:"
    rclone lsf "${REMOTE_PATH}/" 2>/dev/null | grep -E '^(full|incr)-.*-x[0-9][0-9][0-9]\.zfs\.gz\.age$' | sed 's/-x[0-9][0-9][0-9]\.zfs\.gz\.age$//' | sort -u || echo "No backups found"
    exit 1
fi

echo "Found ${#CHUNK_FILES[@]} chunks: ${CHUNK_FILES[0]} ... ${CHUNK_FILES[-1]}"

# === CONNECTION TEST ===
echo "Testing connection to $PROVIDER_NAME..."
if ! rclone lsd "${SELECTED_REMOTE%:*}:" >/dev/null 2>&1; then
    echo "ERROR: Cannot connect to $PROVIDER_NAME"
    exit 1
fi
echo "✓ Connected to $PROVIDER_NAME"

# === TARGET DATASET VALIDATION ===
if zfs list "$TARGET_DATASET" >/dev/null 2>&1; then
    echo "WARNING: Target dataset $TARGET_DATASET already exists"
    read -p "Do you want to destroy and recreate it? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Restore cancelled"
        exit 1
    fi
    echo "Destroying existing dataset..."
    zfs destroy -r "$TARGET_DATASET"
fi

# === RESTORE PROCESS ===
WORK_DIR="${TEMP_DIR}/offsite-restore-$(date +%s)"
mkdir -p "$WORK_DIR"
cd "$WORK_DIR"

echo ""
echo "Starting restore process..."
echo "Working directory: $WORK_DIR"

# Download all chunks
echo "Step 1: Downloading chunks..."
for chunk_file in "${CHUNK_FILES[@]}"; do
    echo "  Downloading: $chunk_file"
    rclone copy "${REMOTE_PATH}/${chunk_file}" ./
done

# Decrypt and decompress chunks
echo "Step 2: Decrypting and decompressing chunks..."
for chunk_file in "${CHUNK_FILES[@]}"; do
    echo "  Processing: $chunk_file"
    # Extract the chunk number from filename (e.g., full-auto-20250716-161605-x001.zfs.gz.age -> 001)
    chunk_num=$(echo "$chunk_file" | sed 's/.*-x\([0-9][0-9][0-9]\)\.zfs\.gz\.age$/\1/')
    age -d -i "$AGE_PRIVATE_KEY_FILE" "$chunk_file" | gunzip > "chunk-${chunk_num}.restored"
    echo "    ✓ Restored: chunk-${chunk_num}.restored"
done

# Reconstitute stream
echo "Step 3: Reconstituting ZFS stream..."
cat chunk-*.restored > complete-stream.zfs
echo "Complete stream size: $(wc -c < complete-stream.zfs) bytes"

# ZFS receive
echo "Step 4: Performing ZFS receive..."
zfs recv -F "$TARGET_DATASET" < complete-stream.zfs

# Cleanup
cd /
rm -rf "$WORK_DIR"

echo ""
echo "✅ Restore complete!"
echo ""
echo "Source: $SOURCE_DATASET ($BACKUP_PREFIX)"
echo "Target: $TARGET_DATASET"
echo "Chunks processed: ${#CHUNK_FILES[@]}"
echo "Provider: $PROVIDER_NAME"
echo ""
echo "You can now:"
echo "  - Mount: zfs mount $TARGET_DATASET"
echo "  - List snapshots: zfs list -t snapshot -r $TARGET_DATASET"
echo "  - Access data at: $(zfs get -H -o value mountpoint $TARGET_DATASET 2>/dev/null || echo 'mount point')"